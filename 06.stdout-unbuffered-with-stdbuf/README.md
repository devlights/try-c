# これは何？

C言語における標準出力 (`stdout`) のバッファリングの挙動を確認するためのサンプルです。

`app.c` は、1秒スリープしながら1文字ずつ出力する処理を5回繰り返すプログラムです。
`Taskfile.yml` には、このプログラムを以下の3つの異なる条件で実行するタスクが定義されています。

1.  **`./app`**: 通常実行。出力先がターミナルのため、`stdout` は **ラインバッファ** モードになります。
2.  **`./app 1`**: プログラム内で `setbuf(stdout, NULL)` を呼び出し、`stdout` を **アンバッファ** モードにして実行します。
3.  **`./app | tee out.txt`**: 出力をパイプに繋いで実行。出力先がファイルやパイプの場合、`stdout` は **フルバッファ** モードになります。

このサンプルを実行することで、以下のことが分かります。

- **ラインバッファ/フルバッファの場合**: `sleep` を挟んでいるにも関わらず、5秒間何も出力されず、最後にまとめて `[0][1][2][3][4]` が表示されます。これは、出力がバッファに溜め込まれ、プログラム終了時などにまとめて書き出されるためです。
- **アンバッファの場合**: `[0]`、`[1]`、... と1秒ごとにリアルタイムで出力されます。これは、バッファを介さず即座に書き込みが行われるためです。

このように、`stdout` のバッファリング設定によってプログラムの出力タイミングが大きく変わることを確認できます。

## ラインバッファ、フルバッファ、アンバッファの違い

UNIX環境におけるI/Oバッファリングには、主に以下の3つの種類があります。

| 種類 | 説明 | デフォルト | 定数 |
| --- | --- | --- | --- |
| **フルバッファ** | バッファが完全に満たされたときにのみ、実際のI/Oが実行される。 | ファイル、パイプ | `_IOFBF` |
| **ラインバッファ** | 改行文字 (`\n`) が出力されるか、バッファが満杯になるか、入力が要求されたときにI/Oが実行される。 | 端末 (インタラクティブデバイス) | `_IOLBF` |
| **アンバッファ** | 書き込み操作のたびに、即座にI/Oが実行される。 | `stderr` | `_IONBF` |

- **フルバッファ (`_IOFBF`)**: システムコールの回数が最も少なく効率的ですが、データが書き出されるまでの遅延が最も大きくなります。ファイルへの出力など、大量のデータを一度に書き込む場合に適しています。
- **ラインバッファ (`_IOLBF`)**: ユーザーがキーボードから入力し、Enterキーを押すたびに応答を返すような、対話的な処理に適しています。`stdout`が端末に接続されている場合のデフォルトです。
- **アンバッファ (`_IONBF`)**: リアルタイム性が求められるログ出力や、エラーメッセージの表示に適しています。`stderr`はデフォルトでこの設定になっており、エラーが即座に表示されるようになっています。

## 実行結果

```sh
$ task
task: [build] $CC $CFLAGS -o app app.c
task: [run] ./app
[start]
バッファサイズ: 1024 bytes
ラインバッファ?: はい
状態: ラインバッファ (_IOLBF)
[0][1][2][3][4]
---------------------------------
task: [run] ./app 1
[start]
バッファサイズ: 1 bytes
ラインバッファ?: いいえ
状態: ✓ アンバッファ (_IONBF)
[0][1][2][3][4]
---------------------------------
task: [run] ./app | tee out.txt
[start]
バッファサイズ: 4096 bytes
ラインバッファ?: いいえ
状態: フルバッファ (_IOFBF)
[0][1][2][3][4]
```

アンバッファ以外の場合は、５秒後に一気に一行分出力される。
