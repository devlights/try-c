# これは何？

AI (Perplexity) に、作ってもらったC言語向けの辞書（HashMap) です。

AIが提示してくれたコードに少し手を加えて、ベンチマークコードを追加しました。

## 実行

```sh
$ make
挿入時間: 0.277740 秒
検索時間: 0.101101 秒 (1000000/1000000 見つかりました)
削除時間: 0.119226 秒 (1000000/1000000 削除されました)
```

## 説明

### ハッシュマップ実装概要

C言語でGoのmapやC#のDictionaryに相当するハッシュマップを実装するために、以下の要素を考慮しました：

- キーと値の型: 汎用性を持たせるために、キーは文字列 (char*) とし、値はvoid*で任意の型を格納可能にします。
- ハッシュ関数: 効率的なハッシュ計算のためにdjb2アルゴリズムを採用しました。
- 衝突解決: セパレートチェイニング（チェーン法）を使用し、各バケットにリンクリストを持たせます。
- 動的メモリ管理: ハッシュテーブルのサイズは初期化時に設定し、必要に応じてリサイズ可能に設計します。
- エラー処理: 各関数でのエラー状態を適切に処理し、呼び出し元にフィードバックを提供します。

また、ロードファクター（負荷率）を監視し、一定の閾値を超えた場合にハッシュテーブルのサイズを倍増させるリサイズ機能を導入しています。

- ロードファクター: 現在のエントリ数をテーブルサイズで割った値。一般的に0.75を閾値として使用。
- リサイズ戦略: 現在のサイズを倍にし、新しいバケット配列に全エントリを再配置（再ハッシュ）します。
- リサイズ関数: hashmap_resizeを内部で呼び出します。

---

以下、AIさんが答えてくれた説明。

## ハッシュマップで利用されているアルゴリズムの詳細

提供したハッシュマップ実装では、以下の主要なアルゴリズムとデータ構造が採用されています。それぞれのコンポーネントがどのように機能し、全体としてハッシュマップの性能と効率性に寄与しているかを詳しく説明します。

### **1. ハッシュ関数 (`djb2` アルゴリズム)**

ハッシュ関数は、キーを受け取り、それをハッシュ値に変換する役割を果たします。実装では、**djb2** と呼ばれるハッシュ関数が使用されています。

- **djb2 の特徴**:
  - シンプルで計算が高速。
  - 良好な分散特性を持ち、衝突（異なるキーが同じハッシュ値を持つこと）の発生を抑制。
  - Daniel J. Bernstein によって考案されたアルゴリズム。

- **実装例**:
  ```c
  static unsigned long hash_function(const char *str) {
      unsigned long hash = 5381;
      int c;
      while ((c = *str++))
          hash = ((hash << 5) + hash) + c; // hash * 33 + c
      return hash;
  }
  ```

  この関数は、各文字を順次処理し、ハッシュ値を更新していきます。初期値として `5381` を使用し、各文字に対してハッシュ値を左シフト（`<< 5`）し、加算することで新しいハッシュ値を生成します。

### **2. 衝突解決法 (`セパレートチェイニング`)**

ハッシュ関数によって異なるキーが同じバケットに割り当てられる場合、これを**衝突（コリジョン）**と呼びます。衝突を効率的に管理するために、**セパレートチェイニング（Separate Chaining）**が採用されています。

- **セパレートチェイニングの特徴**:
  - 各バケットにリンクリスト（または他のデータ構造）を持たせ、同じバケットに属するエントリをリンクリストとして格納。
  - 衝突が発生してもリストに追加して管理するため、キーの追加や削除が比較的容易。
  - リンクリストを用いることで、柔軟にエントリ数の増減に対応可能。

- **実装例**:
  ```c
  typedef struct HashMapEntry {
      char *key;
      void *value;
      struct HashMapEntry *next;
  } HashMapEntry;
  
  typedef struct HashMap {
      size_t size;           // バケット数
      size_t count;          // エントリ数
      HashMapEntry **buckets; // バケット配列
  } HashMap;
  
  // エントリの追加
  HashMapEntry *new_entry = malloc(sizeof(HashMapEntry));
  new_entry->key = strdup_custom(key);
  new_entry->value = value;
  new_entry->next = map->buckets[index];
  map->buckets[index] = new_entry;
  ```

  各バケットは `HashMapEntry` 型のリンクリストとして管理され、同じバケットに新しいエントリが追加される際はリストの先頭に挿入されます。

### **3. ロードファクターとリサイズ戦略**

ハッシュマップの **ロードファクター（Load Factor）** は、現在のエントリ数をバケット数で割った値です。ロードファクターが一定の閾値を超えると、リサイズ（バケット数の増加）を行い、パフォーマンスを維持します。

- **ロードファクターの計算**:
  $$ \text{ロードファクター} = \frac{\text{エントリ数}}{\text{バケット数}} $$

- **リサイズ戦略**:
  - **閾値設定**: 一般的に `0.75` を閾値として設定。
  - **リサイズ方法**: 現在のバケット数を倍増し、全エントリを新しいバケット配列に再ハッシュ（再配置）する。
  - **パフォーマンスへの影響**: リサイズは一時的にパフォーマンスを低下させる可能性があるが、適切なタイミングで実施することで全体のパフォーマンスを維持。

- **実装例**:
  ```c
  #define LOAD_FACTOR_THRESHOLD 0.75

  static int hashmap_resize(HashMap *map, size_t new_size) {
      HashMapEntry **new_buckets = calloc(new_size, sizeof(HashMapEntry*));
      if (!new_buckets) return -1;

      // 再ハッシュ
      for (size_t i = 0; i < map->size; i++) {
          HashMapEntry *entry = map->buckets[i];
          while (entry) {
              HashMapEntry *next_entry = entry->next;
              unsigned long hash = hash_function(entry->key);
              size_t index = hash % new_size;

              // 新しいバケットに挿入
              entry->next = new_buckets[index];
              new_buckets[index] = entry;

              entry = next_entry;
          }
      }

      free(map->buckets);
      map->buckets = new_buckets;
      map->size = new_size;

      return 0;
  }

  int hashmap_put(HashMap *map, const char *key, void *value) {
      // ロードファクターのチェック
      double load_factor = (double)(map->count + 1) / map->size;
      if (load_factor > LOAD_FACTOR_THRESHOLD) {
          if (hashmap_resize(map, map->size * 2) != 0) {
              return -1; // リサイズ失敗
          }
      }
      // 以降、エントリの追加処理
  }
  ```

  ロードファクターが `0.75` を超えると、バケット数を倍増し、すべてのエントリを新しいバケットに再配置します。

### **4. メモリ管理とエラー処理**

- **動的メモリ管理**:
  - 各エントリは動的にメモリを割り当てられます（`malloc`）。
  - キーはコピー（`strdup_custom`）され、値はポインタとして格納。
  - ハッシュマップの破棄時には、すべてのエントリと関連するメモリが適切に解放されます。

- **エラー処理**:
  - 関数内でのメモリ割り当て失敗や無効な入力に対して、エラーコードを返すことで呼び出し元に通知。
  - エラーチェックを厳密に行い、信頼性の高い実装を目指しています。

### **5. 全体のアルゴリズムフロー**

1. **作成 (`hashmap_create`)**:
   - 指定された初期サイズでハッシュマップを初期化。
   - バケット配列を動的に割り当て、各バケットを `NULL` に設定。

2. **挿入 (`hashmap_put`)**:
   - 入力キーをハッシュ関数でハッシュ値に変換。
   - ハッシュ値をバケット数で割った余りをインデックスとしてバケットを特定。
   - セパレートチェイニングを用いて、該当バケットのリンクリストを走査し、キーが既に存在する場合は値を更新。
   - キーが存在しない場合は、新しいエントリを作成し、リンクリストの先頭に追加。
   - ロードファクターを計算し、閾値を超えている場合はリサイズを実行。

3. **検索 (`hashmap_get`)**:
   - 入力キーをハッシュ関数でハッシュ値に変換。
   - ハッシュ値をバケット数で割った余りをインデックスとしてバケットを特定。
   - セパレートチェイニングを用いて、該当バケットのリンクリストを走査し、キーが一致するエントリを返却。

4. **削除 (`hashmap_remove`)**:
   - 入力キーをハッシュ関数でハッシュ値に変換。
   - ハッシュ値をバケット数で割った余りをインデックスとしてバケットを特定。
   - セパレートチェイニングを用いて、該当バケットのリンクリストを走査し、キーが一致するエントリを削除。
   - 削除したエントリのメモリを解放し、エントリ数を減少。

5. **破棄 (`hashmap_destroy`)**:
   - すべてのバケットを走査し、リンクリスト内のすべてのエントリを削除およびメモリ解放。
   - バケット配列自体も解放。

### **まとめ**

このハッシュマップ実装は、以下のアルゴリズムとデータ構造を組み合わせることで、高効率かつ柔軟なデータ管理を実現しています：

- **djb2 ハッシュ関数**による効果的なキーの分散。
- **セパレートチェイニング**による衝突の効果的な管理。
- **動的リサイズ**によるロードファクターの維持とパフォーマンスの最適化。
- **厳密なメモリ管理とエラー処理**による信頼性の確保。

これらの要素が連携し、数千件以上のデータを扱う実務的なハッシュマップとして機能します。